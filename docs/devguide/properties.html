<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Organization">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1">
<meta name="google-site-verification" content="k0e8DrbD40s54xHNBqwIsRrSSAkZoprwtEYDnNY06bU" />
<meta name="google-site-verification" content="pnjjbQFvjPwaWhEXY6nSyaS9iyghmH-M_yLHBveDX2M">
<meta itemprop="name" content="AWIPS II - Declared properties">
<meta itemprop="description" content="Polymer is a library that uses the latest web technologies to let you create custom HTML elements. Build anything from a button to a complete application as an encapsulated, reusable element that works across desktop and mobile.">


<meta itemprop="image" content="https://www.polymer-project.org/images/instacod.png">


<title>
  
    Declared properties -
   AWIPS II
</title>
<link rel="publisher" href="https://plus.google.com/107187849809354688692">
<link rel="shortcut icon" href="http://www.unidata.ucar.edu/favicon.ico">
<link href="//fonts.googleapis.com/css?family=RobotoDraft:300,400,500|Source+Code+Pro:400,500,700" rel="stylesheet">
<link href="/polymer-docs/css/site2.css?20160403" rel="stylesheet">
<link href="/polymer-docs/css/site2_sd_rules.css?20160403" rel="stylesheet" shim-shadowdom>



<script src="/polymer-docs/components/webcomponentsjs/webcomponents.min.js?20160403"></script>
<!-- TODO: remove when https://github.com/Polymer/polymer/issues/391 is fixed -->
<link rel="import" href="/polymer-docs/components/polymer/polymer.html">
<link rel="stylesheet" href="/polymer-docs/css/elements/docs-menu.css">
<link rel="import" href="/polymer-docs/elements/common_elements.vulcanized.html?20160403">


</head>
<body id="declared-properties">

<main id="content-container" class="polymer-content">
  <app-drawer id="sidebar" unresolved>
    <div layout vertical id="sidebar-content">
      <div id="logo-container" layout horizontal center>
        <a href="/polymer-docs/" class="logo"><img src="/polymer-docs/images/logos/awips2.png" alt="AWIPS II User Guide"></a>
      </div>

      <docs-menu unresolved flex
		 baseurl='/polymer-docs'
                 coreElements='{"core-header-panel":"components/core-header-panel/core-header-panel.html","core-transition-pages":"components/core-animated-pages/transitions/core-transition-pages.html","core-animated-pages":"components/core-animated-pages/core-animated-pages.html","core-overlay":"components/core-overlay/core-overlay.html","core-toolbar":"components/core-toolbar/core-toolbar.html","core-image":"components/core-image/core-image.html","core-shared-lib":"components/core-shared-lib/core-shared-lib.html","core-a11y-keys":"components/core-a11y-keys/core-a11y-keys.html","core-menu-button":"components/core-menu-button/core-menu-button.html","core-icon":"components/core-icon/core-icon.html","core-selection":"components/core-selection/core-selection.html","core-style":"components/core-style/core-style.html","core-menu":"components/core-menu/core-menu.html","core-submenu":"components/core-menu/core-submenu.html","core-list":"components/core-list/core-list.html","core-dropdown-menu":"components/core-dropdown-menu/core-dropdown-menu.html","core-input":"components/core-input/core-input.html","core-iconset-svg":"components/core-iconset-svg/core-iconset-svg.html","core-field":"components/core-field/core-field.html","core-selector":"components/core-selector/core-selector.html","core-media-query":"components/core-media-query/core-media-query.html","core-animation-group":"components/core-animation/core-animation-group.html","core-animation":"components/core-animation/core-animation.html","core-animation-keyframe":"components/core-animation/core-animation.html","core-animation-prop":"components/core-animation/core-animation.html","core-dropdown":"components/core-dropdown/core-dropdown.html","core-dropdown-base":"components/core-dropdown/core-dropdown-base.html","core-pages":"components/core-pages/core-pages.html","core-meta":"components/core-meta/core-meta.html","core-splitter":"components/core-splitter/core-splitter.html","core-scroll-header-panel":"components/core-scroll-header-panel/core-scroll-header-panel.html","core-tooltip":"components/core-tooltip/core-tooltip.html","core-localstorage":"components/core-localstorage/core-localstorage.html","core-scroll-threshold":"components/core-scroll-threshold/core-scroll-threshold.html","core-drag-drop":"components/core-drag-drop/core-drag-drop.html","core-iconset":"components/core-iconset/core-iconset.html","core-label":"components/core-label/core-label.html","core-signals":"components/core-signals/core-signals.html","core-transition":"components/core-transition/core-transition.html","core-scaffold":"components/core-scaffold/core-scaffold.html","core-drawer-panel":"components/core-drawer-panel/core-drawer-panel.html","core-range":"components/core-range/core-range.html","core-collapse":"components/core-collapse/core-collapse.html","core-xhr":"components/core-ajax/core-xhr.html","core-ajax":"components/core-ajax/core-ajax.html","core-icon-button":"components/core-icon-button/core-icon-button.html","core-item":"components/core-item/core-item.html"}'
                 paperElements='{"paper-dropdown":"components/paper-dropdown/paper-dropdown.html","paper-dropdown-transition":"components/paper-dropdown/paper-dropdown-transition.html","paper-item":"components/paper-item/paper-item.html","paper-dropdown-menu":"components/paper-dropdown-menu/paper-dropdown-menu.html","paper-checkbox":"components/paper-checkbox/paper-checkbox.html","paper-button":"components/paper-button/paper-button.html","paper-button-base":"components/paper-button/paper-button-base.html","paper-menu-button":"components/paper-menu-button/paper-menu-button.html","paper-radio-group":"components/paper-radio-group/paper-radio-group.html","paper-toast":"components/paper-toast/paper-toast.html","paper-char-counter":"components/paper-input/paper-char-counter.html","paper-autogrow-textarea":"components/paper-input/paper-autogrow-textarea.html","paper-input":"components/paper-input/paper-input.html","paper-input-decorator":"components/paper-input/paper-input-decorator.html","paper-slider":"components/paper-slider/paper-slider.html","paper-toggle-button":"components/paper-toggle-button/paper-toggle-button.html","paper-fab":"components/paper-fab/paper-fab.html","paper-ripple":"components/paper-ripple/paper-ripple.html","paper-icon-button":"components/paper-icon-button/paper-icon-button.html","paper-tabs":"components/paper-tabs/paper-tabs.html","paper-tab":"components/paper-tabs/paper-tab.html","paper-shadow":"components/paper-shadow/paper-shadow.html","paper-radio-button":"components/paper-radio-button/paper-radio-button.html","paper-dialog":"components/paper-dialog/paper-dialog.html","paper-action-dialog":"components/paper-dialog/paper-action-dialog.html","paper-dialog-base":"components/paper-dialog/paper-dialog-base.html","paper-dialog-transition":"components/paper-dialog/paper-dialog-transition.html","paper-spinner":"components/paper-spinner/paper-spinner.html","paper-progress":"components/paper-progress/paper-progress.html"}'></docs-menu>
    </div>
  </app-drawer>

  <scroll-area sidebar unresolved class="scrolling">
    <site-banner type="guide" shortname="Docs" unresolved>
      
<app-bar theme="light" class="bar fixed">
</app-bar>

      <header class="shrink">
        <h1>
        
          EDEX Admin
        : Declared properties
        </h1>
      </header>
    </site-banner>

    
    

    <article class="show-permalinks">

      <header class="onlyonmobile">
        <h1>
          
          EDEX Admin
          : Declared properties
        </h1>
      </header>

      
<!--TOC_START-->
<ul id="markdown-toc">
  <li><a href="#property-name-mapping" id="markdown-toc-property-name-mapping">Property name to attribute name mapping</a></li>
  <li><a href="#attribute-deserialization" id="markdown-toc-attribute-deserialization">Attribute deserialization</a>    <ul>
      <li><a href="#configuring-boolean-properties" id="markdown-toc-configuring-boolean-properties">Configuring boolean properties</a></li>
      <li><a href="#configuring-object-and-array-properties" id="markdown-toc-configuring-object-and-array-properties">Configuring object and array properties</a></li>
    </ul>
  </li>
  <li><a href="#configure-values" id="markdown-toc-configure-values">Configuring default property values</a></li>
  <li><a href="#change-callbacks" id="markdown-toc-change-callbacks">Property change observers</a>    <ul>
      <li><a href="#multi-property-observers" id="markdown-toc-multi-property-observers">Observing changes to multiple properties</a></li>
      <li><a href="#observing-path-changes" id="markdown-toc-observing-path-changes">Observing path changes</a></li>
      <li><a href="#deep-observation" id="markdown-toc-deep-observation">Deep path observation</a></li>
      <li><a href="#array-observation" id="markdown-toc-array-observation">Array observation</a></li>
      <li><a href="#array-mutation" id="markdown-toc-array-mutation">Array mutation methods</a></li>
    </ul>
  </li>
  <li><a href="#notify" id="markdown-toc-notify">Property change notification events (notify)</a></li>
  <li><a href="#read-only" id="markdown-toc-read-only">Read-only properties</a></li>
  <li><a href="#computed-properties" id="markdown-toc-computed-properties">Computed properties</a></li>
  <li><a href="#attribute-reflection" id="markdown-toc-attribute-reflection">Reflecting properties to attributes</a>    <ul>
      <li><a href="#attribute-serialization" id="markdown-toc-attribute-serialization">Attribute serialization</a></li>
    </ul>
  </li>
</ul>
<!--TOC_END-->

<p>You can declare properties on your custom element by adding them to
the <code>properties</code> object on your prototype. Adding a property to the <code>properties</code> 
object allows a user to configure the property from markup (see 
<a href="#attribute-deserialization">attribute deserialization</a> for details).
<strong>Any property that’s part of your element’s public API should be declared in the 
<code>properties</code> object.</strong></p>

<p>In addition, the <code>properties</code> object can be used to specify:</p>

<ul>
  <li>Property type.</li>
  <li>Default value.</li>
  <li>Property change observer. Calls a method whenever the property value changes.</li>
  <li>Read-only status. Prevents accidental changes to the property value.</li>
  <li>Two-way data binding support. Fires an event whenever the property value changes.</li>
  <li>Computed property. Dynamically calculates a value based on other properties.</li>
  <li>Property reflection to attribute. Updates the corresponding attribute value when the property value changes.</li>
</ul>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    user: String,
    isHappy: Boolean,
    count: {
      type: Number,
      readOnly: true,
      notify: true
    }
  },

  ready: function() {
    this.textContent = 'Hello World, I am a Custom Element!';
  }

});
</code></pre>

<p>The <code>properties</code> object supports the following keys for each property:</p>

<table>
<tr>
<th>Key</th><th>Details</th>
</tr>
<tr>
<td><code>type</code></td>
<td>
Type: constructor (one of <code>Boolean</code>, <code>Date</code>, <code>Number</code>, <code>String</code>, <code>Array</code> or <code>Object</code>)<br />

Attribute type, used for deserializing from an attribute. Unlike 0.5, the
property's type is explicit, specified using the type's constructor. See 
<a href="#attribute-deserialization">attribute deserialization</a> for more information.

</td>
</tr>
<tr>
<td><code>value</code></td>
<td>
Type: <code>boolean</code>, <code>number</code>, <code>string</code> or <code>function</code>.<br />

Default value for the property. If `value` is a function, the function is
invoked and the return value is used as the default value of the property. If
the default value should be an array or object unique to the instance, create
the array or object inside a function. See 
<a href="#configure-values">Configuring default property values</a> for more information.
</td>
</tr>
<tr>
<td><code>reflectToAttribute</code></td>
<td>Type: <code>boolean</code><br /> 

Set to `true` to cause the corresponding attribute to be set on the host node
when the property value changes. If the property value is Boolean, the attribute
is created as a standard HTML boolean attribute (set if true, not set if false).
For other property types, the attribute value is a string representation of the
property value. Equivalent to `reflect` in AWIPS II 0.5.
See <a href="#attribute-reflection">Reflecting properties to attributes</a> for
more information.
</td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td>Type: <code>boolean</code><br /> 

If `true`, the property can't be set directly by assignment or data binding. See <a href="#read-only">Read-only properties</a>.
</td>
</tr>
<tr>
<td><code>notify</code></td>
<td>Type: <code>boolean</code><br /> 

If `true`, the property is available for two-way data binding. In addition, an
event, <code><var>propertyName</var>-changed</code> is fired whenever the
property changes. See <a href="#notify">Property change notification events (notify)</a>
for more information.
</td>
</tr>
<tr>
<td><code>computed</code></td>
<td>Type: <code>string</code><br />

The value is interpreted as a method name and argument list. The method is invoked
to calculate the value whenever any of the argument values changes. Computed
properties are always read-only. See <a href="#computed-properties">Computed properties</a> 
for more information.
</td>
</tr>
<tr>
<td><code>observer</code></td>
<td>Type: <code>string</code><br />

The value is interpreted as a method name to be invoked when the property value 
changes. Note that unlike in 0.5, <strong>property change handlers must be registered 
explicitly.</strong> The <code><var>propertyName</var>Changed</code> method will not be 
invoked automatically. See <a href="#change-callbacks">Property change callbacks (observers)</a> 
for more information.
</td>
</tr>
</table>

<h2 id="property-name-mapping">Property name to attribute name mapping</h2>

<p>For data binding, deserializing properties from attributes, and reflecting
properties back to attributes, AWIPS II maps attribute names to property
names and the reverse.</p>

<p>When mapping attribute names to property names:</p>

<ul>
  <li>
    <p>Attribute names are converted to lowercase property names. For example,
the attribute <code>firstName</code> maps to <code>firstname</code>.</p>
  </li>
  <li>
    <p>Attribute names with <em>dashes</em> are converted to <em>camelCase</em> property names 
by capitalizing the character following each dash, then removing the dashes. 
For example, the attribute <code>first-name</code> maps to <code>firstName</code>.</p>
  </li>
</ul>

<p>The same mappings happen in reverse when converting property names to attribute
names (for example, if a property is defined using <code>reflectToAttribute: true</code>.)</p>

<p class="alert alert-info"><strong>Compatibility note:</strong> In 0.5, Polymer attempted to map attribute names to corresponding properties.
For example, the attribute <code>foobar</code> would map to the property <code>fooBar</code> if it was
defined on the element. This <strong>does not happen in 1.0</strong> — attribute to property
mappings are set up on the element at registration time based on the rules
described above.</p>

<h2 id="attribute-deserialization">Attribute deserialization</h2>

<p>If a property is configured in the <code>properties</code> object, an attribute on the
instance matching the property name will be deserialized according to the type
specified and assigned to a property of the same name on the element instance.</p>

<p>If no other <code>properties</code> options are specified for a property, the <code>type</code>
(specified using the type constructor, e.g. <code>Object</code>, <code>String</code>, etc.) can be set
directly as the value of the property in the <code>properties</code> object; otherwise it
should be provided as the value to the <code>type</code> key in the <code>properties</code>
configuration object.</p>

<p>The type system includes support for Boolean and Number values, Object and Array values 
expressed as JSON, or Date objects expressed as any Date-parsable string 
representation.</p>

<p>Boolean properties are set based on the <em>presence</em> of the attribute: 
if the attribute exists at all, the property is set to <code>true</code>, regardless 
of the attribute <em>value</em>. If the attribute is absent, the property 
gets its default value.</p>

<p>Example:</p>

<pre><code>&lt;script&gt;

  Polymer({

    is: 'x-custom',

    properties: {
      user: String,
      manager: {
        type: Boolean,
        notify: true
      }
    },

    attached: function() {
      // render
      this.textContent = 'Hello World, my user is ' + (this.user || 'nobody') + '.\n' +
        'This user is ' + (this.manager ? '' : 'not') + ' a manager.';
    }

  });

&lt;/script&gt;

&lt;x-custom user="Scott" manager&gt;&lt;/x-custom&gt;
&lt;!--
&lt;x-custom&gt;'s text content becomes:
Hello World, my user is Scott.
This user is a manager.
--&gt;
</code></pre>

<p>In order to configure camel-case properties of elements using attributes, dash-
case should be used in the attribute name.  Example:</p>

<pre><code>&lt;script&gt;

  Polymer({

    is: 'x-custom',

    properties: {
      userName: String
    }

  });

&lt;/script&gt;

&lt;x-custom user-name="Scott"&gt;&lt;/x-custom&gt;
&lt;!-- Sets &lt;x-custom&gt;.userName = 'Scott';  --&gt;
</code></pre>

<p class="alert alert-info"><strong>Note:</strong> Deserialization occurs both at create time, and at runtime (for
example, when the attribute is changed using <code>setAttribute</code>).  However, it is
encouraged that attributes only be used for configuring properties in static
markup, and instead that properties are set directly for changes at runtime.</p>

<h3 id="configuring-boolean-properties">Configuring boolean properties</h3>

<p>For a Boolean property to be configurable from markup, it must default to <code>false</code>. If it defaults to <code>true</code>, you cannot set it to <code>false</code> from markup, since the presence of the attribute, with or without a value, equates to <code>true</code>. This is the standard behavior for attributes in the web platform.</p>

<p>If this behavior doesn’t fit your use case, you can use a string-valued or number-valued attribute instead.</p>

<h3 id="configuring-object-and-array-properties">Configuring object and array properties</h3>

<p>For object and array properties you can pass an object or array in JSON format:</p>

<pre><code>&lt;my-element book='{ "title": "Persuasion", "author": "Austen" }'&gt;&lt;/my-element&gt;
</code></pre>

<p>Note that JSON requires double quotes, as shown above.</p>

<h2 id="configure-values">Configuring default property values</h2>

<p>Default values for properties may be specified in the <code>properties</code> object using
the <code>value</code> field.  The value may either be a primitive value, or a function
that returns a value.</p>

<p>If you provide a function, AWIPS II calls the function once
<em>per element instance</em>.</p>

<p>When initializing a property to an object or array value, use a function to 
ensure that each element gets its own copy of the value, rather than having 
an object or array shared across all instances of the element.</p>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',
   
  properties: {
  
    mode: {
      type: String,
      value: 'auto'
    },
    
    data: {
      type: Object,
      notify: true,
      value: function() { return {}; }
    }
  
  }

});
</code></pre>

<h2 id="change-callbacks">Property change observers</h2>

<p>Custom element properties may be observed for changes by specifying <code>observer</code>
property in the <code>properties</code> object for the property that gives the name of a function
to call.  When the property changes, the change handler will be called with the
new and old values as arguments.</p>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    disabled: {
      type: Boolean,
      observer: '_disabledChanged'
    },
    highlight: {
      observer: '_highlightChanged'
    }
  },

  _disabledChanged: function(newValue, oldValue) {
    this.toggleClass('disabled', newValue);
    this.highlight = true;
  },

  _highlightChanged: function() {
    this.classList.add('highlight');
    this.async(function() {
      this.classList.remove('highlight');
    }, 300);
  }

});
</code></pre>

<p class="alert alert-info"><strong>Compatibility note:</strong> The argument order for change handlers is currently the
<strong>opposite</strong> of the order used in 0.5.</p>

<p>Property change observation is achieved in Polymer by installing setters on the
custom element prototype for properties with registered interest (as opposed to
observation via <code>Object.observe</code> or dirty checking, for example).</p>

<h3 id="multi-property-observers">Observing changes to multiple properties</h3>

<p>To observe changes to a set of properties, use the <code>observers</code>
array.</p>

<p>These observers differ from single-property observers in a few ways:</p>

<ul>
  <li>Observers are not invoked until all dependent properties are defined (<code>!== undefined</code>).<br />
So each dependent properties should have a default <code>value</code> defined in <code>properties</code> (or otherwise 
be initialized to a non-<code>undefined</code> value) to ensure the observer is called.</li>
  <li>Observers do not receive <code>old</code> values as arguments, only new values.  Only single-property 
observers defined in the <code>properties</code> object receive both <code>old</code> and <code>new</code> values.</li>
</ul>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    preload: Boolean,
    src: String,
    size: String
  },

  observers: [
    'updateImage(preload, src, size)'
  ],

  updateImage: function(preload, src, size) {
    // ... do work using dependent values
  }

});
</code></pre>

<p>In addition to properties, observers can also observe <a href="#observing-path-changes">paths to sub-properties</a>,
<a href="#deep-observation">paths with wildcards</a>, or <a href="#array-observation">array changes</a>.</p>

<h3 id="observing-path-changes">Observing path changes</h3>

<p>You can also observe changes to object sub-properties using the 
<code>observers</code> array, by specifying a full path (<code>user.manager.name</code>)
as a function argument.</p>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    user: Object
  },

  observers: [
    'userManagerChanged(user.manager)'
  ],

  userManagerChanged: function(user) {
    console.log('new manager name is ' + user.name);
  }

});
</code></pre>

<p>To observe a change to a path (object sub-property) the value <strong>must be changed in
one of the following ways</strong>:</p>

<ul>
  <li>Using a Polymer <a href="data-binding.html#property-binding">property binding</a> to another element.</li>
  <li>Using the <a href="data-binding.html#set-path"><code>set</code></a> API, which provides the
required notification to elements with registered interest.</li>
</ul>

<h3 id="deep-observation">Deep path observation</h3>

<p>To call an observer when any (deep) sub-property of an
object changes, specify a path with a wildcard (<code>*</code>).</p>

<p>When you specify a path with a wildcard, the argument passed to your
observer is a change record object with the following properties:</p>

<ul>
  <li><code>path</code>. Path to the property that changed.</li>
  <li><code>value</code>. New value of the path that changed.</li>
  <li><code>base</code>. The object matching the non-wildcard portion of the path.</li>
</ul>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    user: Object
  },

  observers: [
    'userManagerChanged(user.manager.*)'
  ],

  userManagerChanged: function(changeRecord) {
    if (changeRecord.path == 'user.manager') {
      // user.manager object itself changed
      console.log('new manager name is ' + changeRecord.value.name);
    } else {
      // sub-property of user.manager changed
      console.log(changeRecord.path + ' changed to ' + changeRecord.value);
    }
  }

});
</code></pre>

<h3 id="array-observation">Array observation</h3>

<p>Finally, to observe mutations to arrays (changes resulting from calls to <code>push</code>,
<code>pop</code>, <code>shift</code>, <code>unshift</code>, and <code>splice</code>, generally referred to as “splices”),
specify a path to an array followed by <code>.splices</code> as an argument to the observer 
function.</p>

<p>The value received by the observer for the <code>splices</code> path of an array is a
change records with the following properties:</p>

<ul>
  <li>
    <p><code>indexSplices</code>. Lists the set of changes that occurred to the array, in 
 terms of array indicies. Each <code>indexSplices</code> record contains the following 
 properties:</p>

    <ul>
      <li><code>index</code>. Position where the splice started.</li>
      <li><code>removed</code>. Array of <code>removed</code> items.</li>
      <li><code>addedCount</code>. Number of new items inserted at <code>index</code>.</li>
    </ul>
  </li>
  <li>
    <p><code>keySplices</code>. Lists the set of changes that occurred to the array in terms
of “keys” used by Polymer for identifying array elements. Each <code>keySplices</code> record 
contains the following properties:</p>

    <ul>
      <li><code>added</code>. Array of added keys.</li>
      <li><code>removed</code>. Array of removed keys.</li>
    </ul>
  </li>
</ul>

<p>Example:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    users: {
      type: Array,
      value: function() {
        return [];
      }
    }
  },

  observers: [
    'usersAddedOrRemoved(users.splices)'
  ],

  usersAddedOrRemoved: function(changeRecord) {
    changeRecord.indexSplices.forEach(function(s) {
      s.removed.forEach(function(user) {
        console.log(user.name + ' was removed');
      });
      console.log(s.addedCount + ' users were added');
    }, this);
  },

  addUser: function() {
    this.push('users', {name: "Jack Aubrey"});
  }

});
</code></pre>

<p class="alert alert-info"><strong>Array mutation methods.</strong> Observing changes to arrays is dependent on the change to the array
being made through one of the <a href="#array-mutation">array mutation methods</a> provided
on Polymer elements, which provides the required notification to elements with
registered interest.</p>

<p>When you specify a wildcard path on an array, the observer is for both splices as
well as array element sub-property changes.  So the  observer in the
following example will be called for all additions, removals, and deep changes
that occur in the array:</p>

<pre><code>Polymer({

  is: 'x-custom',

  properties: {
    users: {
      type: Array,
      value: function() {
        return [];
      }
    }      
  },

  observers: [
    'usersChanged(users.*)'
  ],

  usersChanged: function(changeRecord) {
    if (changeRecord.path == 'users.splices') {
      // a user was added or removed
    } else {
      // an individual user or its sub-properties changed
      // check "changeRecord.path" to determine what changed
    }
  }

});
</code></pre>

<h3 id="array-mutation">Array mutation methods</h3>

<p>When modifying arrays, a set of array mutation methods are provided on AWIPS II
element prototypes which mimic <code>Array.prototype</code> methods, with the exception that
they take a <code>path</code> string as the first argument.  The <code>path</code> argument identifies
an array on the element to mutate, with the following arguments matching those
of the native <code>Array</code> methods.</p>

<p>These methods perform the mutation action on
the array, and then notify other elements that may be bound to the same
array of the changes.  You must use these methods when mutating an array
to ensure that any elements watching the array (via observers, computed properties,
or data bindings) are kept in sync.</p>

<p>Every Polymer element has the following array mutation methods available:</p>

<ul>
  <li><code>push(path, item1, [..., itemN])</code></li>
  <li><code>pop(path)</code></li>
  <li><code>unshift(path, item1, [..., itemN])</code></li>
  <li><code>shift(path)</code></li>
  <li><code>splice(path, index, removeCount, [item1, ..., itemN])</code></li>
</ul>

<p>Example:</p>

<pre><code>&lt;dom-module id="custom-element"&gt;
  &lt;template&gt;
    &lt;template is="dom-repeat"&gt;&lt;/template&gt;
  &lt;/template&gt;

  &lt;script&gt;
    Polymer({

      is: 'custom-element',

      addUser: function(user) {
        this.push('users', user);
      },

      removeUser: function(user) {
        var index = this.users.indexOf(user);
        this.splice('users', index, 1);
      }

    });
  &lt;/script&gt;
&lt;/dom-module&gt;
</code></pre>

<h2 id="notify">Property change notification events (notify)</h2>

<p>When a property is set to <code>notify: true</code>, an event,
<code><var>propertyName</var>-changed</code>, is fired whenever the property
value changes. These events are used by the two-way data binding system, and can
also notify external scripts and frameworks to respond to changes in the element.</p>

<p>For more on property change notifications and data binding, see  <a href="data-binding.html#property-notification">Property
change notification and two-way binding</a>.</p>

<h2 id="read-only">Read-only properties</h2>

<p>When a property only “produces” data and never consumes data, this can be made
explicit to avoid accidental changes from the host by setting the <code>readOnly</code>
flag to <code>true</code> in the <code>properties</code> property definition.  In order for the
element to actually change the value of the property, it must use a private
generated setter of the convention <code>_set<var>Property</var>(value)</code>.</p>

<pre><code>&lt;script&gt;
  Polymer({

    properties: {
      response: {
        type: Object,
        readOnly: true,
        notify: true
      }
    },

    responseHandler: function(response) {
      this._setResponse(response);
    }

  });
&lt;/script&gt;
</code></pre>

<p>For more on read-only properties and data binding, see 
<a href="data-binding.html#property-notification">Property change notification and two-way binding</a>.</p>

<h2 id="computed-properties">Computed properties</h2>

<p>Polymer supports virtual properties whose values are calculated from other
properties.</p>

<p>To define a computed property, add it to the <code>properties</code> object with a 
<code>computed</code> key mapping to a computing function:</p>

<pre><code>fullName: {
  type: String,
  computed: 'computeFullName(first, last)'
} 
</code></pre>

<p>The function is provided as a string with dependent properties as arguments 
in parenthesis. The function will be called once for any change to 
the dependent properties.</p>

<p>The computing function is not invoked until <strong>all</strong> dependent properties 
are defined (<code>!== undefined</code>). So each dependent properties should have a 
default <code>value</code> defined in <code>properties</code> (or otherwise be initialized to a 
non-<code>undefined</code> value) to ensure the property is computed.</p>

<p class="alert alert-info"><strong>Note:</strong> The definition of a computing function looks like the 
definition of a <a href="#multi-property-observers">multi-property observer</a>,
and the two act almost identically. The only difference is that the 
computed property function returns a value that’s exposed as a virtual property.</p>

<pre><code>&lt;dom-module id="x-custom"&gt;

  &lt;template&gt;
    My name is &lt;span&gt;{{fullName}}&lt;/span&gt;
  &lt;/template&gt;

  &lt;script&gt;
    Polymer({

      is: 'x-custom',

      properties: {

        first: String,

        last: String,

        fullName: {
          type: String,
          // when `first` or `last` changes `computeFullName` is called once
          // and the value it returns is stored as `fullName`
          computed: 'computeFullName(first, last)'
        } 

      },

      computeFullName: function(first, last) {
        return first + ' ' + last;
      }

    });
  &lt;/script&gt;

&lt;/dom-module&gt;
</code></pre>

<p>Arguments to computing functions may be simple properties on the element, as 
well as any of the arguments types supported by <code>observers</code>, including <a href="#observing-path-changes">paths</a>, 
<a href="#deep-observation">paths with wildcards</a>, and <a href="#array-observation">paths to array splices</a>.<br />
The arguments received by the computing function match those described in the sections referenced above.</p>

<p class="alert alert-info"><strong>Note:</strong> If you only need a computed property for a data binding, you
can use a computed binding instead. See 
<a href="data-binding.html#annotated-computed">Computed bindings</a>.</p>

<h2 id="attribute-reflection">Reflecting properties to attributes</h2>

<p>In specific cases, it may be useful to keep an HTML attribute value in sync with
a property value.  This may be achieved by setting <code>reflectToAttribute: true</code> on
a property in the <code>properties</code> configuration object.  This will cause any change
to the property to be serialized out to an attribute of the same name.</p>

<pre><code>&lt;script&gt;
  Polymer({

    properties: {
     response: {
        type: Object,
        reflectToAttribute: true
     }
    },

    responseHandler: function(response) {
      this.response = 'loaded';
      // results in this.setAttribute('response', 'loaded');
    }

  });
&lt;/script&gt;
</code></pre>

<h3 id="attribute-serialization">Attribute serialization</h3>

<p>When reflecting a property to an attribute or 
<a href="data-binding.html#attribute-binding">binding a property to an attribute</a>,
the property value is <em>serialized</em> to the attribute.</p>

<p>By default, values are serialized according to value’s  <em>current</em> type
(regardless of the property’s <code>type</code> value):</p>

<ul>
  <li><code>String</code>. No serialization required.</li>
  <li><code>Date</code> or <code>Number</code>. Serialized using  <code>toString</code>.</li>
  <li><code>Boolean</code>. Results in a non-valued attribute to be either set (<code>true</code>) or removed (<code>false</code>).</li>
  <li><code>Array</code> or <code>Object</code>. Serialized using <code>JSON.stringify</code>.</li>
</ul>

<p>To supply custom serialization for a custom element, override your element’s <code>serialize</code> method.</p>

    </article>

    <footer>
  <div>
    <div class="links">
      <a href="https://www.facebook.com/unidata" title="Unidata on Facebook" tabindex="-1"><paper-button><core-icon icon="social:post-facebook"></core-icon>Facebook</paper-button></a>
      <a href="https://twitter.com/intent/follow?screen_name=unidata" data-twitter-follow title="Follow @Unidata on Twitter" tabindex="-1"><paper-button><core-icon icon="social:post-twitter"></core-icon>Twitter</paper-button></a>
      <a href="https://github.com/Unidata/awips2"><paper-button class="github" tabindex="-1"><core-icon icon="social:post-github"></core-icon>GitHub</paper-button></a>
      <a href="https://github.com/Unidata/awips2/issues/new" tabindex="-1"><paper-button><core-icon icon="bug-report"></core-icon>File a bug</paper-button></a>
    </div>

  </div>
</footer>





<script src="/polymer-docs/js/prettify/prettify.js"></script>

<!-- <script src="/polymer-docs/js/bower_components/smoothscroll/smoothscroll.js"></script> -->
<script src="/polymer-docs/js/app.js?20160403"></script>


  </scroll-area>

</main>

</body>
</html>
